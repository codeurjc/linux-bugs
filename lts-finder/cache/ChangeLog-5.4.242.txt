commit ea7862c507eca54ea6caad9dcfc8bba5e749fbde
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 26 11:24:06 2023 +0200

    Linux 5.4.242
    
    Link: https://lore.kernel.org/r/20230424131123.040556994@linuxfoundation.org
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Chris Paterson (CIP) <chris.paterson2@renesas.com>
    Tested-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d54a9f999ea769a579379e8386bd50bda9997a9f
Author: Ekaterina Orlova <vorobushek.ok@gmail.com>
Date:   Fri Apr 21 15:35:39 2023 +0100

    ASN.1: Fix check for strdup() success
    
    commit 5a43001c01691dcbd396541e6faa2c0077378f48 upstream.
    
    It seems there is a misprint in the check of strdup() return code that
    can lead to NULL pointer dereference.
    
    Found by Linux Verification Center (linuxtesting.org) with SVACE.
    
    Fixes: 4520c6a49af8 ("X.509: Add simple ASN.1 grammar compiler")
    Signed-off-by: Ekaterina Orlova <vorobushek.ok@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: James Bottomley <jejb@linux.ibm.com>
    Cc: Jarkko Sakkinen <jarkko@kernel.org>
    Cc: keyrings@vger.kernel.org
    Cc: linux-kbuild@vger.kernel.org
    Link: https://lore.kernel.org/r/20230315172130.140-1-vorobushek.ok@gmail.com/
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2500d7edebfb390e9127eb9297b132027545ec62
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Mar 29 07:35:32 2023 +0300

    iio: adc: at91-sama5d2_adc: fix an error code in at91_adc_allocate_trigger()
    
    commit 73a428b37b9b538f8f8fe61caa45e7f243bab87c upstream.
    
    The at91_adc_allocate_trigger() function is supposed to return error
    pointers.  Returning a NULL will cause an Oops.
    
    Fixes: 5e1a1da0f8c9 ("iio: adc: at91-sama5d2_adc: add hw trigger and buffer support")
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Link: https://lore.kernel.org/r/5d728f9d-31d1-410d-a0b3-df6a63a2c8ba@kili.mountain
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 760c2e6dee325e7f8b2303c1c06379dccd6682f2
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Mar 22 22:45:44 2023 +0100

    pwm: meson: Explicitly set .polarity in .get_state()
    
    commit 8caa81eb950cb2e9d2d6959b37d853162d197f57 upstream.
    
    The driver only supports normal polarity. Complete the implementation of
    .get_state() by setting .polarity accordingly.
    
    This fixes a regression that was possible since commit c73a3107624d
    ("pwm: Handle .get_state() failures") which stopped to zero-initialize
    the state passed to the .get_state() callback. This was reported at
    https://forum.odroid.com/viewtopic.php?f=177&t=46360 . While this was an
    unintended side effect, the real issue is the driver's callback not
    setting the polarity.
    
    There is a complicating fact, that the .apply() callback fakes support
    for inversed polarity. This is not (and cannot) be matched by
    .get_state(). As fixing this isn't easy, only point it out in a comment
    to prevent authors of other drivers from copying that approach.
    
    Fixes: c375bcbaabdb ("pwm: meson: Read the full hardware state in meson_pwm_get_state()")
    Reported-by: Munehisa Kamata <kamatam@amazon.com>
    Acked-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Link: https://lore.kernel.org/r/20230310191405.2606296-1-u.kleine-koenig@pengutronix.de
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7f2b8046da837db765c092cfdecb5c16cf840f11
Author: Gao Xiang <xiang@kernel.org>
Date:   Sat Nov 14 11:06:01 2020 -0800

    xfs: fix forkoff miscalculation related to XFS_LITINO(mp)
    
    commit ada49d64fb3538144192181db05de17e2ffc3551 upstream.
    
    Currently, commit e9e2eae89ddb dropped a (int) decoration from
    XFS_LITINO(mp), and since sizeof() expression is also involved,
    the result of XFS_LITINO(mp) is simply as the size_t type
    (commonly unsigned long).
    
    Considering the expression in xfs_attr_shortform_bytesfit():
      offset = (XFS_LITINO(mp) - bytes) >> 3;
    let "bytes" be (int)340, and
        "XFS_LITINO(mp)" be (unsigned long)336.
    
    on 64-bit platform, the expression is
      offset = ((unsigned long)336 - (int)340) >> 3 =
               (int)(0xfffffffffffffffcUL >> 3) = -1
    
    but on 32-bit platform, the expression is
      offset = ((unsigned long)336 - (int)340) >> 3 =
               (int)(0xfffffffcUL >> 3) = 0x1fffffff
    instead.
    
    so offset becomes a large positive number on 32-bit platform, and
    cause xfs_attr_shortform_bytesfit() returns maxforkoff rather than 0.
    
    Therefore, one result is
      "ASSERT(new_size <= XFS_IFORK_SIZE(ip, whichfork));"
    
    assertion failure in xfs_idata_realloc(), which was also the root
    cause of the original bugreport from Dennis, see:
       https://bugzilla.redhat.com/show_bug.cgi?id=1894177
    
    And it can also be manually triggered with the following commands:
      $ touch a;
      $ setfattr -n user.0 -v "`seq 0 80`" a;
      $ setfattr -n user.1 -v "`seq 0 80`" a
    
    on 32-bit platform.
    
    Fix the case in xfs_attr_shortform_bytesfit() by bailing out
    "XFS_LITINO(mp) < bytes" in advance suggested by Eric and a misleading
    comment together with this bugfix suggested by Darrick. It seems the
    other users of XFS_LITINO(mp) are not impacted.
    
    Fixes: e9e2eae89ddb ("xfs: only check the superblock version for dinode size calculation")
    Cc: <stable@vger.kernel.org> # 5.7+
    Reported-and-tested-by: Dennis Gilmore <dgilmore@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Gao Xiang <hsiangkao@redhat.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Chandan Babu R <chandan.babu@oracle.com>
    Acked-by: Darrick J. Wong <djwong@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c27a6bb1788f6868137d1669d55e9f5335214984
Author: Kuniyuki Iwashima <kuniyu@amazon.com>
Date:   Wed Oct 19 15:36:01 2022 -0700

    sctp: Call inet6_destroy_sock() via sk->sk_destruct().
    
    commit 6431b0f6ff1633ae598667e4cdd93830074a03e8 upstream.
    
    After commit d38afeec26ed ("tcp/udp: Call inet6_destroy_sock()
    in IPv6 sk->sk_destruct()."), we call inet6_destroy_sock() in
    sk->sk_destruct() by setting inet6_sock_destruct() to it to make
    sure we do not leak inet6-specific resources.
    
    SCTP sets its own sk->sk_destruct() in the sctp_init_sock(), and
    SCTPv6 socket reuses it as the init function.
    
    To call inet6_sock_destruct() from SCTPv6 sk->sk_destruct(), we
    set sctp_v6_destruct_sock() in a new init function.
    
    Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ziyang Xuan <william.xuanziyang@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 97ce6cde1f5120bc00bb6ee1fced2416edab20de
Author: Kuniyuki Iwashima <kuniyu@amazon.com>
Date:   Wed Oct 19 15:36:00 2022 -0700

    dccp: Call inet6_destroy_sock() via sk->sk_destruct().
    
    commit 1651951ebea54970e0bda60c638fc2eee7a6218f upstream.
    
    After commit d38afeec26ed ("tcp/udp: Call inet6_destroy_sock()
    in IPv6 sk->sk_destruct()."), we call inet6_destroy_sock() in
    sk->sk_destruct() by setting inet6_sock_destruct() to it to make
    sure we do not leak inet6-specific resources.
    
    DCCP sets its own sk->sk_destruct() in the dccp_init_sock(), and
    DCCPv6 socket shares it by calling the same init function via
    dccp_v6_init_sock().
    
    To call inet6_sock_destruct() from DCCPv6 sk->sk_destruct(), we
    export it and set dccp_v6_sk_destruct() in the init function.
    
    Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ziyang Xuan <william.xuanziyang@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a01b75620e1a9cdd0f6ecb6c110907a8fce7243b
Author: Kuniyuki Iwashima <kuniyu@amazon.com>
Date:   Wed Oct 19 15:35:59 2022 -0700

    inet6: Remove inet6_destroy_sock() in sk->sk_prot->destroy().
    
    commit b5fc29233d28be7a3322848ebe73ac327559cdb9 upstream.
    
    After commit d38afeec26ed ("tcp/udp: Call inet6_destroy_sock()
    in IPv6 sk->sk_destruct()."), we call inet6_destroy_sock() in
    sk->sk_destruct() by setting inet6_sock_destruct() to it to make
    sure we do not leak inet6-specific resources.
    
    Now we can remove unnecessary inet6_destroy_sock() calls in
    sk->sk_prot->destroy().
    
    DCCP and SCTP have their own sk->sk_destruct() function, so we
    change them separately in the following patches.
    
    Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
    Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ziyang Xuan <william.xuanziyang@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9374db5bd1e3b5464da8718d4e484530ed70f2e7
Author: Kuniyuki Iwashima <kuniyu@amazon.com>
Date:   Thu Oct 6 11:53:47 2022 -0700

    tcp/udp: Call inet6_destroy_sock() in IPv6 sk->sk_destruct().
    
    commit d38afeec26ed4739c640bf286c270559aab2ba5f upstream.
    
    Originally, inet6_sk(sk)->XXX were changed under lock_sock(), so we were
    able to clean them up by calling inet6_destroy_sock() during the IPv6 ->
    IPv4 conversion by IPV6_ADDRFORM.  However, commit 03485f2adcde ("udpv6:
    Add lockless sendmsg() support") added a lockless memory allocation path,
    which could cause a memory leak:
    
    setsockopt(IPV6_ADDRFORM)                 sendmsg()
    +-----------------------+                 +-------+
    - do_ipv6_setsockopt(sk, ...)             - udpv6_sendmsg(sk, ...)
      - sockopt_lock_sock(sk)                   ^._ called via udpv6_prot
        - lock_sock(sk)                             before WRITE_ONCE()
      - WRITE_ONCE(sk->sk_prot, &tcp_prot)
      - inet6_destroy_sock()                    - if (!corkreq)
      - sockopt_release_sock(sk)                  - ip6_make_skb(sk, ...)
        - release_sock(sk)                          ^._ lockless fast path for
                                                        the non-corking case
    
                                                    - __ip6_append_data(sk, ...)
                                                      - ipv6_local_rxpmtu(sk, ...)
                                                        - xchg(&np->rxpmtu, skb)
                                                          ^._ rxpmtu is never freed.
    
                                                    - goto out_no_dst;
    
                                                - lock_sock(sk)
    
    For now, rxpmtu is only the case, but not to miss the future change
    and a similar bug fixed in commit e27326009a3d ("net: ping6: Fix
    memleak in ipv6_renew_options()."), let's set a new function to IPv6
    sk->sk_destruct() and call inet6_cleanup_sock() there.  Since the
    conversion does not change sk->sk_destruct(), we can guarantee that
    we can clean up IPv6 resources finally.
    
    We can now remove all inet6_destroy_sock() calls from IPv6 protocol
    specific ->destroy() functions, but such changes are invasive to
    backport.  So they can be posted as a follow-up later for net-next.
    
    Fixes: 03485f2adcde ("udpv6: Add lockless sendmsg() support")
    Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Ziyang Xuan <william.xuanziyang@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2ac4697b7779d6e6767fc23beae3fa4130eea8b8
Author: Kuniyuki Iwashima <kuniyu@amazon.com>
Date:   Thu Oct 6 11:53:46 2022 -0700

    udp: Call inet6_destroy_sock() in setsockopt(IPV6_ADDRFORM).
    
    commit 21985f43376cee092702d6cb963ff97a9d2ede68 upstream.
    
    Commit 4b340ae20d0e ("IPv6: Complete IPV6_DONTFRAG support") forgot
    to add a change to free inet6_sk(sk)->rxpmtu while converting an IPv6
    socket into IPv4 with IPV6_ADDRFORM.  After conversion, sk_prot is
    changed to udp_prot and ->destroy() never cleans it up, resulting in
    a memory leak.
    
    This is due to the discrepancy between inet6_destroy_sock() and
    IPV6_ADDRFORM, so let's call inet6_destroy_sock() from IPV6_ADDRFORM
    to remove the difference.
    
    However, this is not enough for now because rxpmtu can be changed
    without lock_sock() after commit 03485f2adcde ("udpv6: Add lockless
    sendmsg() support").  We will fix this case in the following patch.
    
    Note we will rename inet6_destroy_sock() to inet6_cleanup_sock() and
    remove unnecessary inet6_destroy_sock() calls in sk_prot->destroy()
    in the future.
    
    Fixes: 4b340ae20d0e ("IPv6: Complete IPV6_DONTFRAG support")
    Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Ziyang Xuan <william.xuanziyang@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5a62248c58556c395c604d4161d53afae16b6fad
Author: Baokun Li <libaokun1@huawei.com>
Date:   Wed Apr 19 06:46:10 2023 +0000

    ext4: fix use-after-free in ext4_xattr_set_entry
    
    [ Upstream commit 67d7d8ad99beccd9fe92d585b87f1760dc9018e3 ]
    
    Hulk Robot reported a issue:
    ==================================================================
    BUG: KASAN: use-after-free in ext4_xattr_set_entry+0x18ab/0x3500
    Write of size 4105 at addr ffff8881675ef5f4 by task syz-executor.0/7092
    
    CPU: 1 PID: 7092 Comm: syz-executor.0 Not tainted 4.19.90-dirty #17
    Call Trace:
    [...]
     memcpy+0x34/0x50 mm/kasan/kasan.c:303
     ext4_xattr_set_entry+0x18ab/0x3500 fs/ext4/xattr.c:1747
     ext4_xattr_ibody_inline_set+0x86/0x2a0 fs/ext4/xattr.c:2205
     ext4_xattr_set_handle+0x940/0x1300 fs/ext4/xattr.c:2386
     ext4_xattr_set+0x1da/0x300 fs/ext4/xattr.c:2498
     __vfs_setxattr+0x112/0x170 fs/xattr.c:149
     __vfs_setxattr_noperm+0x11b/0x2a0 fs/xattr.c:180
     __vfs_setxattr_locked+0x17b/0x250 fs/xattr.c:238
     vfs_setxattr+0xed/0x270 fs/xattr.c:255
     setxattr+0x235/0x330 fs/xattr.c:520
     path_setxattr+0x176/0x190 fs/xattr.c:539
     __do_sys_lsetxattr fs/xattr.c:561 [inline]
     __se_sys_lsetxattr fs/xattr.c:557 [inline]
     __x64_sys_lsetxattr+0xc2/0x160 fs/xattr.c:557
     do_syscall_64+0xdf/0x530 arch/x86/entry/common.c:298
     entry_SYSCALL_64_after_hwframe+0x44/0xa9
    RIP: 0033:0x459fe9
    RSP: 002b:00007fa5e54b4c08 EFLAGS: 00000246 ORIG_RAX: 00000000000000bd
    RAX: ffffffffffffffda RBX: 000000000051bf60 RCX: 0000000000459fe9
    RDX: 00000000200003c0 RSI: 0000000020000180 RDI: 0000000020000140
    RBP: 000000000051bf60 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000001009 R11: 0000000000000246 R12: 0000000000000000
    R13: 00007ffc73c93fc0 R14: 000000000051bf60 R15: 00007fa5e54b4d80
    [...]
    ==================================================================
    
    Above issue may happen as follows:
    -------------------------------------
    ext4_xattr_set
      ext4_xattr_set_handle
        ext4_xattr_ibody_find
          >> s->end < s->base
          >> no EXT4_STATE_XATTR
          >> xattr_check_inode is not executed
        ext4_xattr_ibody_set
          ext4_xattr_set_entry
           >> size_t min_offs = s->end - s->base
           >> UAF in memcpy
    
    we can easily reproduce this problem with the following commands:
        mkfs.ext4 -F /dev/sda
        mount -o debug_want_extra_isize=128 /dev/sda /mnt
        touch /mnt/file
        setfattr -n user.cat -v `seq -s z 4096|tr -d '[:digit:]'` /mnt/file
    
    In ext4_xattr_ibody_find, we have the following assignment logic:
      header = IHDR(inode, raw_inode)
             = raw_inode + EXT4_GOOD_OLD_INODE_SIZE + i_extra_isize
      is->s.base = IFIRST(header)
                 = header + sizeof(struct ext4_xattr_ibody_header)
      is->s.end = raw_inode + s_inode_size
    
    In ext4_xattr_set_entry
      min_offs = s->end - s->base
               = s_inode_size - EXT4_GOOD_OLD_INODE_SIZE - i_extra_isize -
                 sizeof(struct ext4_xattr_ibody_header)
      last = s->first
      free = min_offs - ((void *)last - s->base) - sizeof(__u32)
           = s_inode_size - EXT4_GOOD_OLD_INODE_SIZE - i_extra_isize -
             sizeof(struct ext4_xattr_ibody_header) - sizeof(__u32)
    
    In the calculation formula, all values except s_inode_size and
    i_extra_size are fixed values. When i_extra_size is the maximum value
    s_inode_size - EXT4_GOOD_OLD_INODE_SIZE, min_offs is -4 and free is -8.
    The value overflows. As a result, the preceding issue is triggered when
    memcpy is executed.
    
    Therefore, when finding xattr or setting xattr, check whether
    there is space for storing xattr in the inode to resolve this issue.
    
    Cc: stable@kernel.org
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Baokun Li <libaokun1@huawei.com>
    Reviewed-by: Ritesh Harjani (IBM) <ritesh.list@gmail.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Link: https://lore.kernel.org/r/20220616021358.2504451-3-libaokun1@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Tudor Ambarus <tudor.ambarus@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3b0044cb28f73142493bec86cb2cb65e5eec84c2
Author: Ritesh Harjani <riteshh@linux.ibm.com>
Date:   Wed Apr 19 06:46:09 2023 +0000

    ext4: remove duplicate definition of ext4_xattr_ibody_inline_set()
    
    [ Upstream commit 310c097c2bdbea253d6ee4e064f3e65580ef93ac ]
    
    ext4_xattr_ibody_inline_set() & ext4_xattr_ibody_set() have the exact
    same definition.  Hence remove ext4_xattr_ibody_inline_set() and all
    its call references. Convert the callers of it to call
    ext4_xattr_ibody_set() instead.
    
    [ Modified to preserve ext4_xattr_ibody_set() and remove
      ext4_xattr_ibody_inline_set() instead. -- TYT ]
    
    Signed-off-by: Ritesh Harjani <riteshh@linux.ibm.com>
    Link: https://lore.kernel.org/r/fd566b799bbbbe9b668eb5eecde5b5e319e3694f.1622685482.git.riteshh@linux.ibm.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Tudor Ambarus <tudor.ambarus@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3c4fdbf368baed92b09f860ec8f7dedebf66075b
Author: Tudor Ambarus <tudor.ambarus@linaro.org>
Date:   Wed Apr 19 06:46:08 2023 +0000

    Revert "ext4: fix use-after-free in ext4_xattr_set_entry"
    
    This reverts commit bb8592efcf8ef2f62947745d3182ea05b5256a15 which is
    commit 67d7d8ad99beccd9fe92d585b87f1760dc9018e3 upstream.
    
    The order in which patches are queued to stable matters. This patch
    has a logical dependency on commit 310c097c2bdbea253d6ee4e064f3e65580ef93ac
    upstream, and failing to queue the latter results in a null-ptr-deref
    reported at the Link below.
    
    In order to avoid conflicts on stable, revert the commit just so that we
    can queue its prerequisite patch first and then queue the same after.
    
    Link: https://syzkaller.appspot.com/bug?extid=d5ebf56f3b1268136afd
    Signed-off-by: Tudor Ambarus <tudor.ambarus@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ef2aab86c34c8dfe5dc4f118774d6d2be10ecada
Author: Pingfan Liu <kernelfans@gmail.com>
Date:   Mon Aug 3 13:49:48 2020 +0800

    x86/purgatory: Don't generate debug info for purgatory.ro
    
    commit 52416ffcf823ee11aa19792715664ab94757f111 upstream.
    
    Purgatory.ro is a standalone binary that is not linked against the rest of
    the kernel.  Its image is copied into an array that is linked to the
    kernel, and from there kexec relocates it wherever it desires.
    
    Unlike the debug info for vmlinux, which can be used for analyzing crash
    such info is useless in purgatory.ro. And discarding them can save about
    200K space.
    
     Original:
       259080  kexec-purgatory.o
     Stripped debug info:
        29152  kexec-purgatory.o
    
    Signed-off-by: Pingfan Liu <kernelfans@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Steve Wahl <steve.wahl@hpe.com>
    Acked-by: Dave Young <dyoung@redhat.com>
    Link: https://lore.kernel.org/r/1596433788-3784-1-git-send-email-kernelfans@gmail.com
    [Alyssa: fixed for LLVM_IAS=1 by adding -g to AFLAGS_REMOVE_*]
    Signed-off-by: Alyssa Ross <hi@alyssa.is>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c22aefaef8ae12c8e29d646f0ec76cdfe7e1cfc7
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Sat Apr 8 21:33:48 2023 +0100

    MIPS: Define RUNTIME_DISCARD_EXIT in LD script
    
    commit 6dcbd0a69c84a8ae7a442840a8cf6b1379dc8f16 upstream.
    
    MIPS's exit sections are discarded at runtime as well.
    
    Fixes link error:
    `.exit.text' referenced in section `__jump_table' of fs/fuse/inode.o:
    defined in discarded section `.exit.text' of fs/fuse/inode.o
    
    Fixes: 99cb0d917ffa ("arch: fix broken BuildID for arm64 and riscv")
    Reported-by: "kernelci.org bot" <bot@kernelci.org>
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a5167e902b64a9d912f8c219fca193e72a17202a
Author: Bhavya Kapoor <b-kapoor@ti.com>
Date:   Fri Mar 17 14:57:11 2023 +0530

    mmc: sdhci_am654: Set HIGH_SPEED_ENA for SDR12 and SDR25
    
    commit 2265098fd6a6272fde3fd1be5761f2f5895bd99a upstream.
    
    Timing Information in Datasheet assumes that HIGH_SPEED_ENA=1 should be
    set for SDR12 and SDR25 modes. But sdhci_am654 driver clears
    HIGH_SPEED_ENA register. Thus, Modify sdhci_am654 to not clear
    HIGH_SPEED_ENA (HOST_CONTROL[2]) bit for SDR12 and SDR25 speed modes.
    
    Fixes: e374e87538f4 ("mmc: sdhci_am654: Clear HISPD_ENA in some lower speed modes")
    Signed-off-by: Bhavya Kapoor <b-kapoor@ti.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20230317092711.660897-1-b-kapoor@ti.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1b8b54fc55a448d52d611108b7237fd168be5874
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sat Apr 1 22:03:27 2023 +0200

    memstick: fix memory leak if card device is never registered
    
    commit 4b6d621c9d859ff89e68cebf6178652592676013 upstream.
    
    When calling dev_set_name() memory is allocated for the name for the
    struct device.  Once that structure device is registered, or attempted
    to be registerd, with the driver core, the driver core will handle
    cleaning up that memory when the device is removed from the system.
    
    Unfortunatly for the memstick code, there is an error path that causes
    the struct device to never be registered, and so the memory allocated in
    dev_set_name will be leaked.  Fix that leak by manually freeing it right
    before the memory for the device is freed.
    
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: Alex Dubov <oakad@yahoo.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: linux-mmc@vger.kernel.org
    Fixes: 0252c3b4f018 ("memstick: struct device - replace bus_id with dev_name(), dev_set_name()")
    Cc: stable <stable@kernel.org>
    Co-developed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Co-developed-by: Mirsad Goran Todorovac <mirsad.todorovac@alu.unizg.hr>
    Signed-off-by: Mirsad Goran Todorovac <mirsad.todorovac@alu.unizg.hr>
    Link: https://lore.kernel.org/r/20230401200327.16800-1-gregkh@linuxfoundation.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5ad61a5268de37ba6e729382a4e215035b487782
Author: Ryusuke Konishi <konishi.ryusuke@gmail.com>
Date:   Tue Apr 18 02:35:13 2023 +0900

    nilfs2: initialize unused bytes in segment summary blocks
    
    commit ef832747a82dfbc22a3702219cc716f449b24e4a upstream.
    
    Syzbot still reports uninit-value in nilfs_add_checksums_on_logs() for
    KMSAN enabled kernels after applying commit 7397031622e0 ("nilfs2:
    initialize "struct nilfs_binfo_dat"->bi_pad field").
    
    This is because the unused bytes at the end of each block in segment
    summaries are not initialized.  So this fixes the issue by padding the
    unused bytes with null bytes.
    
    Link: https://lkml.kernel.org/r/20230417173513.12598-1-konishi.ryusuke@gmail.com
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@gmail.com>
    Tested-by: Ryusuke Konishi <konishi.ryusuke@gmail.com>
    Reported-by: syzbot+048585f3f4227bb2b49b@syzkaller.appspotmail.com
      Link: https://syzkaller.appspot.com/bug?extid=048585f3f4227bb2b49b
    Cc: Alexander Potapenko <glider@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 988766b9d1241de9e7f08fe5c06a1771aeda3b28
Author: Brian Masney <bmasney@redhat.com>
Date:   Mon Apr 3 21:14:55 2023 -0400

    iio: light: tsl2772: fix reading proximity-diodes from device tree
    
    commit b1cb00d51e361cf5af93649917d9790e1623647e upstream.
    
    tsl2772_read_prox_diodes() will correctly parse the properties from
    device tree to determine which proximity diode(s) to read from, however
    it didn't actually set this value on the struct tsl2772_settings. Let's
    go ahead and fix that.
    
    Reported-by: Tom Rix <trix@redhat.com>
    Link: https://lore.kernel.org/lkml/20230327120823.1369700-1-trix@redhat.com/
    Fixes: 94cd1113aaa0 ("iio: tsl2772: add support for reading proximity led settings from device tree")
    Signed-off-by: Brian Masney <bmasney@redhat.com>
    Link: https://lore.kernel.org/r/20230404011455.339454-1-bmasney@redhat.com
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5cb867f1ecb42fecf25275b846afa930f7fd2504
Author: Juergen Gross <jgross@suse.com>
Date:   Wed Mar 29 10:02:59 2023 +0200

    xen/netback: use same error messages for same errors
    
    [ Upstream commit 2eca98e5b24d01c02b46c67be05a5f98cc9789b1 ]
    
    Issue the same error message in case an illegal page boundary crossing
    has been detected in both cases where this is tested.
    
    Suggested-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Link: https://lore.kernel.org/r/20230329080259.14823-1-jgross@suse.com
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 903f82b1a6b23a3ca9ce891e1c0c28490463ea23
Author: Sagi Grimberg <sagi@grimberg.me>
Date:   Mon Mar 20 15:33:34 2023 +0200

    nvme-tcp: fix a possible UAF when failing to allocate an io queue
    
    [ Upstream commit 88eaba80328b31ef81813a1207b4056efd7006a6 ]
    
    When we allocate a nvme-tcp queue, we set the data_ready callback before
    we actually need to use it. This creates the potential that if a stray
    controller sends us data on the socket before we connect, we can trigger
    the io_work and start consuming the socket.
    
    In this case reported: we failed to allocate one of the io queues, and
    as we start releasing the queues that we already allocated, we get
    a UAF [1] from the io_work which is running before it should really.
    
    Fix this by setting the socket ops callbacks only before we start the
    queue, so that we can't accidentally schedule the io_work in the
    initialization phase before the queue started. While we are at it,
    rename nvme_tcp_restore_sock_calls to pair with nvme_tcp_setup_sock_ops.
    
    [1]:
    [16802.107284] nvme nvme4: starting error recovery
    [16802.109166] nvme nvme4: Reconnecting in 10 seconds...
    [16812.173535] nvme nvme4: failed to connect socket: -111
    [16812.173745] nvme nvme4: Failed reconnect attempt 1
    [16812.173747] nvme nvme4: Reconnecting in 10 seconds...
    [16822.413555] nvme nvme4: failed to connect socket: -111
    [16822.413762] nvme nvme4: Failed reconnect attempt 2
    [16822.413765] nvme nvme4: Reconnecting in 10 seconds...
    [16832.661274] nvme nvme4: creating 32 I/O queues.
    [16833.919887] BUG: kernel NULL pointer dereference, address: 0000000000000088
    [16833.920068] nvme nvme4: Failed reconnect attempt 3
    [16833.920094] #PF: supervisor write access in kernel mode
    [16833.920261] nvme nvme4: Reconnecting in 10 seconds...
    [16833.920368] #PF: error_code(0x0002) - not-present page
    [16833.921086] Workqueue: nvme_tcp_wq nvme_tcp_io_work [nvme_tcp]
    [16833.921191] RIP: 0010:_raw_spin_lock_bh+0x17/0x30
    ...
    [16833.923138] Call Trace:
    [16833.923271]  <TASK>
    [16833.923402]  lock_sock_nested+0x1e/0x50
    [16833.923545]  nvme_tcp_try_recv+0x40/0xa0 [nvme_tcp]
    [16833.923685]  nvme_tcp_io_work+0x68/0xa0 [nvme_tcp]
    [16833.923824]  process_one_work+0x1e8/0x390
    [16833.923969]  worker_thread+0x53/0x3d0
    [16833.924104]  ? process_one_work+0x390/0x390
    [16833.924240]  kthread+0x124/0x150
    [16833.924376]  ? set_kthread_struct+0x50/0x50
    [16833.924518]  ret_from_fork+0x1f/0x30
    [16833.924655]  </TASK>
    
    Reported-by: Yanjun Zhang <zhangyanjun@cestc.cn>
    Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
    Tested-by: Yanjun Zhang <zhangyanjun@cestc.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 34b74c32ff4fc3acbe22123d4232fcbf9caab642
Author: Heiko Carstens <hca@linux.ibm.com>
Date:   Mon Mar 6 12:31:30 2023 +0100

    s390/ptrace: fix PTRACE_GET_LAST_BREAK error handling
    
    [ Upstream commit f9bbf25e7b2b74b52b2f269216a92657774f239c ]
    
    Return -EFAULT if put_user() for the PTRACE_GET_LAST_BREAK
    request fails, instead of silently ignoring it.
    
    Reviewed-by: Sven Schnelle <svens@linux.ibm.com>
    Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 64cd99da25c1c86e503f2c9b85d75fcae5ea9503
Author: Álvaro Fernández Rojas <noltari@gmail.com>
Date:   Thu Mar 23 20:48:41 2023 +0100

    net: dsa: b53: mmap: add phy ops
    
    [ Upstream commit 45977e58ce65ed0459edc9a0466d9dfea09463f5 ]
    
    Implement phy_read16() and phy_write16() ops for B53 MMAP to avoid accessing
    B53_PORT_MII_PAGE registers which hangs the device.
    This access should be done through the MDIO Mux bus controller.
    
    Signed-off-by: Álvaro Fernández Rojas <noltari@gmail.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 89dcf0dd7aae47c94be549f97ac5383ce6c0204a
Author: Damien Le Moal <damien.lemoal@opensource.wdc.com>
Date:   Wed Mar 22 11:22:11 2023 +0900

    scsi: core: Improve scsi_vpd_inquiry() checks
    
    [ Upstream commit f0aa59a33d2ac2267d260fe21eaf92500df8e7b4 ]
    
    Some USB-SATA adapters have broken behavior when an unsupported VPD page is
    probed: Depending on the VPD page number, a 4-byte header with a valid VPD
    page number but with a 0 length is returned. Currently, scsi_vpd_inquiry()
    only checks that the page number is valid to determine if the page is
    valid, which results in receiving only the 4-byte header for the
    non-existent page. This error manifests itself very often with page 0xb9
    for the Concurrent Positioning Ranges detection done by sd_read_cpr(),
    resulting in the following error message:
    
    sd 0:0:0:0: [sda] Invalid Concurrent Positioning Ranges VPD page
    
    Prevent such misleading error message by adding a check in
    scsi_vpd_inquiry() to verify that the page length is not 0.
    
    Signed-off-by: Damien Le Moal <damien.lemoal@opensource.wdc.com>
    Link: https://lore.kernel.org/r/20230322022211.116327-1-damien.lemoal@opensource.wdc.com
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit f729b74bb489ee2d8068d383136cd470a018a3a1
Author: Tomas Henzl <thenzl@redhat.com>
Date:   Fri Mar 24 14:52:49 2023 +0100

    scsi: megaraid_sas: Fix fw_crash_buffer_show()
    
    [ Upstream commit 0808ed6ebbc292222ca069d339744870f6d801da ]
    
    If crash_dump_buf is not allocated then crash dump can't be available.
    Replace logical 'and' with 'or'.
    
    Signed-off-by: Tomas Henzl <thenzl@redhat.com>
    Link: https://lore.kernel.org/r/20230324135249.9733-1-thenzl@redhat.com
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4f4ef354f95dc4063d441370a56b9e5d9505b28a
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Wed Mar 8 11:59:33 2023 -0800

    selftests: sigaltstack: fix -Wuninitialized
    
    [ Upstream commit 05107edc910135d27fe557267dc45be9630bf3dd ]
    
    Building sigaltstack with clang via:
    $ ARCH=x86 make LLVM=1 -C tools/testing/selftests/sigaltstack/
    
    produces the following warning:
      warning: variable 'sp' is uninitialized when used here [-Wuninitialized]
      if (sp < (unsigned long)sstack ||
          ^~
    
    Clang expects these to be declared at global scope; we've fixed this in
    the kernel proper by using the macro `current_stack_pointer`. This is
    defined in different headers for different target architectures, so just
    create a new header that defines the arch-specific register names for
    the stack pointer register, and define it for more targets (at least the
    ones that support current_stack_pointer/ARCH_HAS_CURRENT_STACK_POINTER).
    
    Reported-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Link: https://lore.kernel.org/lkml/CA+G9fYsi3OOu7yCsMutpzKDnBMAzJBCPimBp86LhGBa0eCnEpA@mail.gmail.com/
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Linux Kernel Functional Testing <lkft@linaro.org>
    Tested-by: Anders Roxell <anders.roxell@linaro.org>
    Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit a725dddf21393a6b8a5001bd0d6a76e0505295ae
Author: Jonathan Denose <jdenose@chromium.org>
Date:   Fri Mar 17 03:19:51 2023 -0700

    Input: i8042 - add quirk for Fujitsu Lifebook A574/H
    
    [ Upstream commit f5bad62f9107b701a6def7cac1f5f65862219b83 ]
    
    Fujitsu Lifebook A574/H requires the nomux option to properly
    probe the touchpad, especially when waking from sleep.
    
    Signed-off-by: Jonathan Denose <jdenose@google.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20230303152623.45859-1-jdenose@google.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 9df3f502e33d63be624cb94ec1a879b4c4bf6d91
Author: Douglas Raillard <douglas.raillard@arm.com>
Date:   Mon Mar 6 12:25:49 2023 +0000

    f2fs: Fix f2fs_truncate_partial_nodes ftrace event
    
    [ Upstream commit 0b04d4c0542e8573a837b1d81b94209e48723b25 ]
    
    Fix the nid_t field so that its size is correctly reported in the text
    format embedded in trace.dat files. As it stands, it is reported as
    being of size 4:
    
            field:nid_t nid[3];     offset:24;      size:4; signed:0;
    
    Instead of 12:
    
            field:nid_t nid[3];     offset:24;      size:12;        signed:0;
    
    This also fixes the reported offset of subsequent fields so that they
    match with the actual struct layout.
    
    Signed-off-by: Douglas Raillard <douglas.raillard@arm.com>
    Reviewed-by: Mukesh Ojha <quic_mojha@quicinc.com>
    Reviewed-by: Chao Yu <chao@kernel.org>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 2f3730f182fc7c88bd5dabb6cbbfcdb7481848b6
Author: Sebastian Basierski <sebastianx.basierski@intel.com>
Date:   Mon Apr 17 13:53:45 2023 -0700

    e1000e: Disable TSO on i219-LM card to increase speed
    
    [ Upstream commit 67d47b95119ad589b0a0b16b88b1dd9a04061ced ]
    
    While using i219-LM card currently it was only possible to achieve
    about 60% of maximum speed due to regression introduced in Linux 5.8.
    This was caused by TSO not being disabled by default despite commit
    f29801030ac6 ("e1000e: Disable TSO for buffer overrun workaround").
    Fix that by disabling TSO during driver probe.
    
    Fixes: f29801030ac6 ("e1000e: Disable TSO for buffer overrun workaround")
    Signed-off-by: Sebastian Basierski <sebastianx.basierski@intel.com>
    Signed-off-by: Mateusz Palczewski <mateusz.palczewski@intel.com>
    Tested-by: Naama Meir <naamax.meir@linux.intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Reviewed-by: Simon Horman <simon.horman@corigine.com>
    Link: https://lore.kernel.org/r/20230417205345.1030801-1-anthony.l.nguyen@intel.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 0f0a291cc5208dcc6436974246e8c18106e3c3d2
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Tue Apr 11 15:24:13 2023 +0000

    bpf: Fix incorrect verifier pruning due to missing register precision taints
    
    [ Upstream commit 71b547f561247897a0a14f3082730156c0533fed ]
    
    Juan Jose et al reported an issue found via fuzzing where the verifier's
    pruning logic prematurely marks a program path as safe.
    
    Consider the following program:
    
       0: (b7) r6 = 1024
       1: (b7) r7 = 0
       2: (b7) r8 = 0
       3: (b7) r9 = -2147483648
       4: (97) r6 %= 1025
       5: (05) goto pc+0
       6: (bd) if r6 <= r9 goto pc+2
       7: (97) r6 %= 1
       8: (b7) r9 = 0
       9: (bd) if r6 <= r9 goto pc+1
      10: (b7) r6 = 0
      11: (b7) r0 = 0
      12: (63) *(u32 *)(r10 -4) = r0
      13: (18) r4 = 0xffff888103693400 // map_ptr(ks=4,vs=48)
      15: (bf) r1 = r4
      16: (bf) r2 = r10
      17: (07) r2 += -4
      18: (85) call bpf_map_lookup_elem#1
      19: (55) if r0 != 0x0 goto pc+1
      20: (95) exit
      21: (77) r6 >>= 10
      22: (27) r6 *= 8192
      23: (bf) r1 = r0
      24: (0f) r0 += r6
      25: (79) r3 = *(u64 *)(r0 +0)
      26: (7b) *(u64 *)(r1 +0) = r3
      27: (95) exit
    
    The verifier treats this as safe, leading to oob read/write access due
    to an incorrect verifier conclusion:
    
      func#0 @0
      0: R1=ctx(off=0,imm=0) R10=fp0
      0: (b7) r6 = 1024                     ; R6_w=1024
      1: (b7) r7 = 0                        ; R7_w=0
      2: (b7) r8 = 0                        ; R8_w=0
      3: (b7) r9 = -2147483648              ; R9_w=-2147483648
      4: (97) r6 %= 1025                    ; R6_w=scalar()
      5: (05) goto pc+0
      6: (bd) if r6 <= r9 goto pc+2         ; R6_w=scalar(umin=18446744071562067969,var_off=(0xffffffff00000000; 0xffffffff)) R9_w=-2147483648
      7: (97) r6 %= 1                       ; R6_w=scalar()
      8: (b7) r9 = 0                        ; R9=0
      9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0
      10: (b7) r6 = 0                       ; R6_w=0
      11: (b7) r0 = 0                       ; R0_w=0
      12: (63) *(u32 *)(r10 -4) = r0
      last_idx 12 first_idx 9
      regs=1 stack=0 before 11: (b7) r0 = 0
      13: R0_w=0 R10=fp0 fp-8=0000????
      13: (18) r4 = 0xffff8ad3886c2a00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0
      17: (07) r2 += -4                     ; R2_w=fp-4
      18: (85) call bpf_map_lookup_elem#1   ; R0=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0)
      19: (55) if r0 != 0x0 goto pc+1       ; R0=0
      20: (95) exit
    
      from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????
      21: (77) r6 >>= 10                    ; R6_w=0
      22: (27) r6 *= 8192                   ; R6_w=0
      23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)
      24: (0f) r0 += r6
      last_idx 24 first_idx 19
      regs=40 stack=0 before 23: (bf) r1 = r0
      regs=40 stack=0 before 22: (27) r6 *= 8192
      regs=40 stack=0 before 21: (77) r6 >>= 10
      regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1
      parent didn't have regs=40 stack=0 marks: R0_rw=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0) R6_rw=P0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????
      last_idx 18 first_idx 9
      regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1
      regs=40 stack=0 before 17: (07) r2 += -4
      regs=40 stack=0 before 16: (bf) r2 = r10
      regs=40 stack=0 before 15: (bf) r1 = r4
      regs=40 stack=0 before 13: (18) r4 = 0xffff8ad3886c2a00
      regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0
      regs=40 stack=0 before 11: (b7) r0 = 0
      regs=40 stack=0 before 10: (b7) r6 = 0
      25: (79) r3 = *(u64 *)(r0 +0)         ; R0_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()
      26: (7b) *(u64 *)(r1 +0) = r3         ; R1_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()
      27: (95) exit
    
      from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0
      11: (b7) r0 = 0                       ; R0_w=0
      12: (63) *(u32 *)(r10 -4) = r0
      last_idx 12 first_idx 11
      regs=1 stack=0 before 11: (b7) r0 = 0
      13: R0_w=0 R10=fp0 fp-8=0000????
      13: (18) r4 = 0xffff8ad3886c2a00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0
      17: (07) r2 += -4                     ; R2_w=fp-4
      18: (85) call bpf_map_lookup_elem#1
      frame 0: propagating r6
      last_idx 19 first_idx 11
      regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1
      regs=40 stack=0 before 17: (07) r2 += -4
      regs=40 stack=0 before 16: (bf) r2 = r10
      regs=40 stack=0 before 15: (bf) r1 = r4
      regs=40 stack=0 before 13: (18) r4 = 0xffff8ad3886c2a00
      regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0
      regs=40 stack=0 before 11: (b7) r0 = 0
      parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_r=P0 R7=0 R8=0 R9=0 R10=fp0
      last_idx 9 first_idx 9
      regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1
      parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar() R7_w=0 R8_w=0 R9_rw=0 R10=fp0
      last_idx 8 first_idx 0
      regs=40 stack=0 before 8: (b7) r9 = 0
      regs=40 stack=0 before 7: (97) r6 %= 1
      regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2
      regs=40 stack=0 before 5: (05) goto pc+0
      regs=40 stack=0 before 4: (97) r6 %= 1025
      regs=40 stack=0 before 3: (b7) r9 = -2147483648
      regs=40 stack=0 before 2: (b7) r8 = 0
      regs=40 stack=0 before 1: (b7) r7 = 0
      regs=40 stack=0 before 0: (b7) r6 = 1024
      19: safe
      frame 0: propagating r6
      last_idx 9 first_idx 0
      regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2
      regs=40 stack=0 before 5: (05) goto pc+0
      regs=40 stack=0 before 4: (97) r6 %= 1025
      regs=40 stack=0 before 3: (b7) r9 = -2147483648
      regs=40 stack=0 before 2: (b7) r8 = 0
      regs=40 stack=0 before 1: (b7) r7 = 0
      regs=40 stack=0 before 0: (b7) r6 = 1024
    
      from 6 to 9: safe
      verification time 110 usec
      stack depth 4
      processed 36 insns (limit 1000000) max_states_per_insn 0 total_states 3 peak_states 3 mark_read 2
    
    The verifier considers this program as safe by mistakenly pruning unsafe
    code paths. In the above func#0, code lines 0-10 are of interest. In line
    0-3 registers r6 to r9 are initialized with known scalar values. In line 4
    the register r6 is reset to an unknown scalar given the verifier does not
    track modulo operations. Due to this, the verifier can also not determine
    precisely which branches in line 6 and 9 are taken, therefore it needs to
    explore them both.
    
    As can be seen, the verifier starts with exploring the false/fall-through
    paths first. The 'from 19 to 21' path has both r6=0 and r9=0 and the pointer
    arithmetic on r0 += r6 is therefore considered safe. Given the arithmetic,
    r6 is correctly marked for precision tracking where backtracking kicks in
    where it walks back the current path all the way where r6 was set to 0 in
    the fall-through branch.
    
    Next, the pruning logics pops the path 'from 9 to 11' from the stack. Also
    here, the state of the registers is the same, that is, r6=0 and r9=0, so
    that at line 19 the path can be pruned as it is considered safe. It is
    interesting to note that the conditional in line 9 turned r6 into a more
    precise state, that is, in the fall-through path at the beginning of line
    10, it is R6=scalar(umin=1), and in the branch-taken path (which is analyzed
    here) at the beginning of line 11, r6 turned into a known const r6=0 as
    r9=0 prior to that and therefore (unsigned) r6 <= 0 concludes that r6 must
    be 0 (**):
    
      [...]                                 ; R6_w=scalar()
      9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0
      [...]
    
      from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0
      [...]
    
    The next path is 'from 6 to 9'. The verifier considers the old and current
    state equivalent, and therefore prunes the search incorrectly. Looking into
    the two states which are being compared by the pruning logic at line 9, the
    old state consists of R6_rwD=Pscalar() R9_rwD=0 R10=fp0 and the new state
    consists of R1=ctx(off=0,imm=0) R6_w=scalar(umax=18446744071562067968)
    R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0. While r6 had the reg->precise flag
    correctly set in the old state, r9 did not. Both r6'es are considered as
    equivalent given the old one is a superset of the current, more precise one,
    however, r9's actual values (0 vs 0x80000000) mismatch. Given the old r9
    did not have reg->precise flag set, the verifier does not consider the
    register as contributing to the precision state of r6, and therefore it
    considered both r9 states as equivalent. However, for this specific pruned
    path (which is also the actual path taken at runtime), register r6 will be
    0x400 and r9 0x80000000 when reaching line 21, thus oob-accessing the map.
    
    The purpose of precision tracking is to initially mark registers (including
    spilled ones) as imprecise to help verifier's pruning logic finding equivalent
    states it can then prune if they don't contribute to the program's safety
    aspects. For example, if registers are used for pointer arithmetic or to pass
    constant length to a helper, then the verifier sets reg->precise flag and
    backtracks the BPF program instruction sequence and chain of verifier states
    to ensure that the given register or stack slot including their dependencies
    are marked as precisely tracked scalar. This also includes any other registers
    and slots that contribute to a tracked state of given registers/stack slot.
    This backtracking relies on recorded jmp_history and is able to traverse
    entire chain of parent states. This process ends only when all the necessary
    registers/slots and their transitive dependencies are marked as precise.
    
    The backtrack_insn() is called from the current instruction up to the first
    instruction, and its purpose is to compute a bitmask of registers and stack
    slots that need precision tracking in the parent's verifier state. For example,
    if a current instruction is r6 = r7, then r6 needs precision after this
    instruction and r7 needs precision before this instruction, that is, in the
    parent state. Hence for the latter r7 is marked and r6 unmarked.
    
    For the class of jmp/jmp32 instructions, backtrack_insn() today only looks
    at call and exit instructions and for all other conditionals the masks
    remain as-is. However, in the given situation register r6 has a dependency
    on r9 (as described above in **), so also that one needs to be marked for
    precision tracking. In other words, if an imprecise register influences a
    precise one, then the imprecise register should also be marked precise.
    Meaning, in the parent state both dest and src register need to be tracked
    for precision and therefore the marking must be more conservative by setting
    reg->precise flag for both. The precision propagation needs to cover both
    for the conditional: if the src reg was marked but not the dst reg and vice
    versa.
    
    After the fix the program is correctly rejected:
    
      func#0 @0
      0: R1=ctx(off=0,imm=0) R10=fp0
      0: (b7) r6 = 1024                     ; R6_w=1024
      1: (b7) r7 = 0                        ; R7_w=0
      2: (b7) r8 = 0                        ; R8_w=0
      3: (b7) r9 = -2147483648              ; R9_w=-2147483648
      4: (97) r6 %= 1025                    ; R6_w=scalar()
      5: (05) goto pc+0
      6: (bd) if r6 <= r9 goto pc+2         ; R6_w=scalar(umin=18446744071562067969,var_off=(0xffffffff80000000; 0x7fffffff),u32_min=-2147483648) R9_w=-2147483648
      7: (97) r6 %= 1                       ; R6_w=scalar()
      8: (b7) r9 = 0                        ; R9=0
      9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0
      10: (b7) r6 = 0                       ; R6_w=0
      11: (b7) r0 = 0                       ; R0_w=0
      12: (63) *(u32 *)(r10 -4) = r0
      last_idx 12 first_idx 9
      regs=1 stack=0 before 11: (b7) r0 = 0
      13: R0_w=0 R10=fp0 fp-8=0000????
      13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0
      17: (07) r2 += -4                     ; R2_w=fp-4
      18: (85) call bpf_map_lookup_elem#1   ; R0=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0)
      19: (55) if r0 != 0x0 goto pc+1       ; R0=0
      20: (95) exit
    
      from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????
      21: (77) r6 >>= 10                    ; R6_w=0
      22: (27) r6 *= 8192                   ; R6_w=0
      23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)
      24: (0f) r0 += r6
      last_idx 24 first_idx 19
      regs=40 stack=0 before 23: (bf) r1 = r0
      regs=40 stack=0 before 22: (27) r6 *= 8192
      regs=40 stack=0 before 21: (77) r6 >>= 10
      regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1
      parent didn't have regs=40 stack=0 marks: R0_rw=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0) R6_rw=P0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????
      last_idx 18 first_idx 9
      regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1
      regs=40 stack=0 before 17: (07) r2 += -4
      regs=40 stack=0 before 16: (bf) r2 = r10
      regs=40 stack=0 before 15: (bf) r1 = r4
      regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00
      regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0
      regs=40 stack=0 before 11: (b7) r0 = 0
      regs=40 stack=0 before 10: (b7) r6 = 0
      25: (79) r3 = *(u64 *)(r0 +0)         ; R0_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()
      26: (7b) *(u64 *)(r1 +0) = r3         ; R1_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()
      27: (95) exit
    
      from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0
      11: (b7) r0 = 0                       ; R0_w=0
      12: (63) *(u32 *)(r10 -4) = r0
      last_idx 12 first_idx 11
      regs=1 stack=0 before 11: (b7) r0 = 0
      13: R0_w=0 R10=fp0 fp-8=0000????
      13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0
      17: (07) r2 += -4                     ; R2_w=fp-4
      18: (85) call bpf_map_lookup_elem#1
      frame 0: propagating r6
      last_idx 19 first_idx 11
      regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1
      regs=40 stack=0 before 17: (07) r2 += -4
      regs=40 stack=0 before 16: (bf) r2 = r10
      regs=40 stack=0 before 15: (bf) r1 = r4
      regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00
      regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0
      regs=40 stack=0 before 11: (b7) r0 = 0
      parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_r=P0 R7=0 R8=0 R9=0 R10=fp0
      last_idx 9 first_idx 9
      regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1
      parent didn't have regs=240 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar() R7_w=0 R8_w=0 R9_rw=P0 R10=fp0
      last_idx 8 first_idx 0
      regs=240 stack=0 before 8: (b7) r9 = 0
      regs=40 stack=0 before 7: (97) r6 %= 1
      regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2
      regs=240 stack=0 before 5: (05) goto pc+0
      regs=240 stack=0 before 4: (97) r6 %= 1025
      regs=240 stack=0 before 3: (b7) r9 = -2147483648
      regs=40 stack=0 before 2: (b7) r8 = 0
      regs=40 stack=0 before 1: (b7) r7 = 0
      regs=40 stack=0 before 0: (b7) r6 = 1024
      19: safe
    
      from 6 to 9: R1=ctx(off=0,imm=0) R6_w=scalar(umax=18446744071562067968) R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0
      9: (bd) if r6 <= r9 goto pc+1
      last_idx 9 first_idx 0
      regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2
      regs=240 stack=0 before 5: (05) goto pc+0
      regs=240 stack=0 before 4: (97) r6 %= 1025
      regs=240 stack=0 before 3: (b7) r9 = -2147483648
      regs=40 stack=0 before 2: (b7) r8 = 0
      regs=40 stack=0 before 1: (b7) r7 = 0
      regs=40 stack=0 before 0: (b7) r6 = 1024
      last_idx 9 first_idx 0
      regs=200 stack=0 before 6: (bd) if r6 <= r9 goto pc+2
      regs=240 stack=0 before 5: (05) goto pc+0
      regs=240 stack=0 before 4: (97) r6 %= 1025
      regs=240 stack=0 before 3: (b7) r9 = -2147483648
      regs=40 stack=0 before 2: (b7) r8 = 0
      regs=40 stack=0 before 1: (b7) r7 = 0
      regs=40 stack=0 before 0: (b7) r6 = 1024
      11: R6=scalar(umax=18446744071562067968) R9=-2147483648
      11: (b7) r0 = 0                       ; R0_w=0
      12: (63) *(u32 *)(r10 -4) = r0
      last_idx 12 first_idx 11
      regs=1 stack=0 before 11: (b7) r0 = 0
      13: R0_w=0 R10=fp0 fp-8=0000????
      13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)
      16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0
      17: (07) r2 += -4                     ; R2_w=fp-4
      18: (85) call bpf_map_lookup_elem#1   ; R0_w=map_value_or_null(id=3,off=0,ks=4,vs=48,imm=0)
      19: (55) if r0 != 0x0 goto pc+1       ; R0_w=0
      20: (95) exit
    
      from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=scalar(umax=18446744071562067968) R7=0 R8=0 R9=-2147483648 R10=fp0 fp-8=mmmm????
      21: (77) r6 >>= 10                    ; R6_w=scalar(umax=18014398507384832,var_off=(0x0; 0x3fffffffffffff))
      22: (27) r6 *= 8192                   ; R6_w=scalar(smax=9223372036854767616,umax=18446744073709543424,var_off=(0x0; 0xffffffffffffe000),s32_max=2147475456,u32_max=-8192)
      23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)
      24: (0f) r0 += r6
      last_idx 24 first_idx 21
      regs=40 stack=0 before 23: (bf) r1 = r0
      regs=40 stack=0 before 22: (27) r6 *= 8192
      regs=40 stack=0 before 21: (77) r6 >>= 10
      parent didn't have regs=40 stack=0 marks: R0_rw=map_value(off=0,ks=4,vs=48,imm=0) R6_r=Pscalar(umax=18446744071562067968) R7=0 R8=0 R9=-2147483648 R10=fp0 fp-8=mmmm????
      last_idx 19 first_idx 11
      regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1
      regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1
      regs=40 stack=0 before 17: (07) r2 += -4
      regs=40 stack=0 before 16: (bf) r2 = r10
      regs=40 stack=0 before 15: (bf) r1 = r4
      regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00
      regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0
      regs=40 stack=0 before 11: (b7) r0 = 0
      parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar(umax=18446744071562067968) R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0
      last_idx 9 first_idx 0
      regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1
      regs=240 stack=0 before 6: (bd) if r6 <= r9 goto pc+2
      regs=240 stack=0 before 5: (05) goto pc+0
      regs=240 stack=0 before 4: (97) r6 %= 1025
      regs=240 stack=0 before 3: (b7) r9 = -2147483648
      regs=40 stack=0 before 2: (b7) r8 = 0
      regs=40 stack=0 before 1: (b7) r7 = 0
      regs=40 stack=0 before 0: (b7) r6 = 1024
      math between map_value pointer and register with unbounded min value is not allowed
      verification time 886 usec
      stack depth 4
      processed 49 insns (limit 1000000) max_states_per_insn 1 total_states 5 peak_states 5 mark_read 2
    
    Fixes: b5dc0163d8fd ("bpf: precise scalar_value tracking")
    Reported-by: Juan Jose Lopez Jaimez <jjlopezjaimez@google.com>
    Reported-by: Meador Inge <meadori@google.com>
    Reported-by: Simon Scannell <simonscannell@google.com>
    Reported-by: Nenad Stojanovski <thenenadx@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Co-developed-by: Andrii Nakryiko <andrii@kernel.org>
    Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
    Reviewed-by: John Fastabend <john.fastabend@gmail.com>
    Reviewed-by: Juan Jose Lopez Jaimez <jjlopezjaimez@google.com>
    Reviewed-by: Meador Inge <meadori@google.com>
    Reviewed-by: Simon Scannell <simonscannell@google.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit ba610df83b048bdbaf68688828969693efa2852c
Author: Nikita Zhandarovich <n.zhandarovich@fintech.ru>
Date:   Mon Apr 17 05:07:18 2023 -0700

    mlxfw: fix null-ptr-deref in mlxfw_mfa2_tlv_next()
    
    [ Upstream commit c0e73276f0fcbbd3d4736ba975d7dc7a48791b0c ]
    
    Function mlxfw_mfa2_tlv_multi_get() returns NULL if 'tlv' in
    question does not pass checks in mlxfw_mfa2_tlv_payload_get(). This
    behaviour may lead to NULL pointer dereference in 'multi->total_len'.
    Fix this issue by testing mlxfw_mfa2_tlv_multi_get()'s return value
    against NULL.
    
    Found by Linux Verification Center (linuxtesting.org) with static
    analysis tool SVACE.
    
    Fixes: 410ed13cae39 ("Add the mlxfw module for Mellanox firmware flash process")
    Co-developed-by: Natalia Petrova <n.petrova@fintech.ru>
    Signed-off-by: Nikita Zhandarovich <n.zhandarovich@fintech.ru>
    Reviewed-by: Ido Schimmel <idosch@nvidia.com>
    Link: https://lore.kernel.org/r/20230417120718.52325-1-n.zhandarovich@fintech.ru
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d8e120057cee7dbf825fd8c4e4569d3659468125
Author: Aleksandr Loktionov <aleksandr.loktionov@intel.com>
Date:   Mon Apr 3 07:13:18 2023 +0200

    i40e: fix i40e_setup_misc_vector() error handling
    
    [ Upstream commit c86c00c6935505929cc9adb29ddb85e48c71f828 ]
    
    Add error handling of i40e_setup_misc_vector() in i40e_rebuild().
    In case interrupt vectors setup fails do not re-open vsi-s and
    do not bring up vf-s, we have no interrupts to serve a traffic
    anyway.
    
    Fixes: 41c445ff0f48 ("i40e: main driver core")
    Signed-off-by: Aleksandr Loktionov <aleksandr.loktionov@intel.com>
    Tested-by: Pucha Himasekhar Reddy <himasekharx.reddy.pucha@intel.com> (A Contingent worker at Intel)
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 59fba01b6c7220d97682f8177dca168b0b888d36
Author: Aleksandr Loktionov <aleksandr.loktionov@intel.com>
Date:   Fri Mar 24 18:16:38 2023 +0100

    i40e: fix accessing vsi->active_filters without holding lock
    
    [ Upstream commit 8485d093b076e59baff424552e8aecfc5bd2d261 ]
    
    Fix accessing vsi->active_filters without holding the mac_filter_hash_lock.
    Move vsi->active_filters = 0 inside critical section and
    move clear_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state) after the critical
    section to ensure the new filters from other threads can be added only after
    filters cleaning in the critical section is finished.
    
    Fixes: 278e7d0b9d68 ("i40e: store MAC/VLAN filters in a hash with the MAC Address as key")
    Signed-off-by: Aleksandr Loktionov <aleksandr.loktionov@intel.com>
    Tested-by: Pucha Himasekhar Reddy <himasekharx.reddy.pucha@intel.com> (A Contingent worker at Intel)
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 01125379e2dcdd70a64f21c7da273268a9147250
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Apr 17 10:21:36 2023 +0200

    netfilter: nf_tables: fix ifdef to also consider nf_tables=m
    
    [ Upstream commit c55c0e91c813589dc55bea6bf9a9fbfaa10ae41d ]
    
    nftables can be built as a module, so fix the preprocessor conditional
    accordingly.
    
    Fixes: 478b360a47b7 ("netfilter: nf_tables: fix nf_trace always-on with XT_TRACE=n")
    Reported-by: Florian Fainelli <f.fainelli@gmail.com>
    Reported-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 7c1019391bd6cf4a50151eead04a59fb460ca6d2
Author: Xuan Zhuo <xuanzhuo@linux.alibaba.com>
Date:   Fri Apr 14 14:08:35 2023 +0800

    virtio_net: bugfix overflow inside xdp_linearize_page()
    
    [ Upstream commit 853618d5886bf94812f31228091cd37d308230f7 ]
    
    Here we copy the data from the original buf to the new page. But we
    not check that it may be overflow.
    
    As long as the size received(including vnethdr) is greater than 3840
    (PAGE_SIZE -VIRTIO_XDP_HEADROOM). Then the memcpy will overflow.
    
    And this is completely possible, as long as the MTU is large, such
    as 4096. In our test environment, this will cause crash. Since crash is
    caused by the written memory, it is meaningless, so I do not include it.
    
    Fixes: 72979a6c3590 ("virtio_net: xdp, add slowpath case for non contiguous buffers")
    Signed-off-by: Xuan Zhuo <xuanzhuo@linux.alibaba.com>
    Acked-by: Jason Wang <jasowang@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 35dceaeab97c9e5f3fda3b10ce7f8110df0feecd
Author: Gwangun Jung <exsociety@gmail.com>
Date:   Thu Apr 13 19:35:54 2023 +0900

    net: sched: sch_qfq: prevent slab-out-of-bounds in qfq_activate_agg
    
    [ Upstream commit 3037933448f60f9acb705997eae62013ecb81e0d ]
    
    If the TCA_QFQ_LMAX value is not offered through nlattr, lmax is determined by the MTU value of the network device.
    The MTU of the loopback device can be set up to 2^31-1.
    As a result, it is possible to have an lmax value that exceeds QFQ_MIN_LMAX.
    
    Due to the invalid lmax value, an index is generated that exceeds the QFQ_MAX_INDEX(=24) value, causing out-of-bounds read/write errors.
    
    The following reports a oob access:
    
    [   84.582666] BUG: KASAN: slab-out-of-bounds in qfq_activate_agg.constprop.0 (net/sched/sch_qfq.c:1027 net/sched/sch_qfq.c:1060 net/sched/sch_qfq.c:1313)
    [   84.583267] Read of size 4 at addr ffff88810f676948 by task ping/301
    [   84.583686]
    [   84.583797] CPU: 3 PID: 301 Comm: ping Not tainted 6.3.0-rc5 #1
    [   84.584164] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
    [   84.584644] Call Trace:
    [   84.584787]  <TASK>
    [   84.584906] dump_stack_lvl (lib/dump_stack.c:107 (discriminator 1))
    [   84.585108] print_report (mm/kasan/report.c:320 mm/kasan/report.c:430)
    [   84.585570] kasan_report (mm/kasan/report.c:538)
    [   84.585988] qfq_activate_agg.constprop.0 (net/sched/sch_qfq.c:1027 net/sched/sch_qfq.c:1060 net/sched/sch_qfq.c:1313)
    [   84.586599] qfq_enqueue (net/sched/sch_qfq.c:1255)
    [   84.587607] dev_qdisc_enqueue (net/core/dev.c:3776)
    [   84.587749] __dev_queue_xmit (./include/net/sch_generic.h:186 net/core/dev.c:3865 net/core/dev.c:4212)
    [   84.588763] ip_finish_output2 (./include/net/neighbour.h:546 net/ipv4/ip_output.c:228)
    [   84.589460] ip_output (net/ipv4/ip_output.c:430)
    [   84.590132] ip_push_pending_frames (./include/net/dst.h:444 net/ipv4/ip_output.c:126 net/ipv4/ip_output.c:1586 net/ipv4/ip_output.c:1606)
    [   84.590285] raw_sendmsg (net/ipv4/raw.c:649)
    [   84.591960] sock_sendmsg (net/socket.c:724 net/socket.c:747)
    [   84.592084] __sys_sendto (net/socket.c:2142)
    [   84.593306] __x64_sys_sendto (net/socket.c:2150)
    [   84.593779] do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)
    [   84.593902] entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)
    [   84.594070] RIP: 0033:0x7fe568032066
    [   84.594192] Code: 0e 0d 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 41 89 ca 64 8b 04 25 18 00 00 00 85 c09[ 84.594796] RSP: 002b:00007ffce388b4e8 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
    
    Code starting with the faulting instruction
    ===========================================
    [   84.595047] RAX: ffffffffffffffda RBX: 00007ffce388cc70 RCX: 00007fe568032066
    [   84.595281] RDX: 0000000000000040 RSI: 00005605fdad6d10 RDI: 0000000000000003
    [   84.595515] RBP: 00005605fdad6d10 R08: 00007ffce388eeec R09: 0000000000000010
    [   84.595749] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000040
    [   84.595984] R13: 00007ffce388cc30 R14: 00007ffce388b4f0 R15: 0000001d00000001
    [   84.596218]  </TASK>
    [   84.596295]
    [   84.596351] Allocated by task 291:
    [   84.596467] kasan_save_stack (mm/kasan/common.c:46)
    [   84.596597] kasan_set_track (mm/kasan/common.c:52)
    [   84.596725] __kasan_kmalloc (mm/kasan/common.c:384)
    [   84.596852] __kmalloc_node (./include/linux/kasan.h:196 mm/slab_common.c:967 mm/slab_common.c:974)
    [   84.596979] qdisc_alloc (./include/linux/slab.h:610 ./include/linux/slab.h:731 net/sched/sch_generic.c:938)
    [   84.597100] qdisc_create (net/sched/sch_api.c:1244)
    [   84.597222] tc_modify_qdisc (net/sched/sch_api.c:1680)
    [   84.597357] rtnetlink_rcv_msg (net/core/rtnetlink.c:6174)
    [   84.597495] netlink_rcv_skb (net/netlink/af_netlink.c:2574)
    [   84.597627] netlink_unicast (net/netlink/af_netlink.c:1340 net/netlink/af_netlink.c:1365)
    [   84.597759] netlink_sendmsg (net/netlink/af_netlink.c:1942)
    [   84.597891] sock_sendmsg (net/socket.c:724 net/socket.c:747)
    [   84.598016] ____sys_sendmsg (net/socket.c:2501)
    [   84.598147] ___sys_sendmsg (net/socket.c:2557)
    [   84.598275] __sys_sendmsg (./include/linux/file.h:31 net/socket.c:2586)
    [   84.598399] do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)
    [   84.598520] entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)
    [   84.598688]
    [   84.598744] The buggy address belongs to the object at ffff88810f674000
    [   84.598744]  which belongs to the cache kmalloc-8k of size 8192
    [   84.599135] The buggy address is located 2664 bytes to the right of
    [   84.599135]  allocated 7904-byte region [ffff88810f674000, ffff88810f675ee0)
    [   84.599544]
    [   84.599598] The buggy address belongs to the physical page:
    [   84.599777] page:00000000e638567f refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10f670
    [   84.600074] head:00000000e638567f order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0
    [   84.600330] flags: 0x200000000010200(slab|head|node=0|zone=2)
    [   84.600517] raw: 0200000000010200 ffff888100043180 dead000000000122 0000000000000000
    [   84.600764] raw: 0000000000000000 0000000080020002 00000001ffffffff 0000000000000000
    [   84.601009] page dumped because: kasan: bad access detected
    [   84.601187]
    [   84.601241] Memory state around the buggy address:
    [   84.601396]  ffff88810f676800: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [   84.601620]  ffff88810f676880: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [   84.601845] >ffff88810f676900: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [   84.602069]                                               ^
    [   84.602243]  ffff88810f676980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [   84.602468]  ffff88810f676a00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [   84.602693] ==================================================================
    [   84.602924] Disabling lock debugging due to kernel taint
    
    Fixes: 3015f3d2a3cd ("pkt_sched: enable QFQ to support TSO/GSO")
    Reported-by: Gwangun Jung <exsociety@gmail.com>
    Signed-off-by: Gwangun Jung <exsociety@gmail.com>
    Acked-by: Jamal Hadi Salim<jhs@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit d61f24a454109ff754e61aed6e2617c4231cfd59
Author: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date:   Thu Apr 6 20:18:00 2023 +0300

    regulator: fan53555: Explicitly include bits header
    
    [ Upstream commit 4fb9a5060f73627303bc531ceaab1b19d0a24aef ]
    
    Since commit f2a9eb975ab2 ("regulator: fan53555: Add support for
    FAN53526") the driver makes use of the BIT() macro, but relies on the
    bits header being implicitly included.
    
    Explicitly pull the header in to avoid potential build failures in some
    configurations.
    
    While here, reorder include directives alphabetically.
    
    Fixes: f2a9eb975ab2 ("regulator: fan53555: Add support for FAN53526")
    Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
    Link: https://lore.kernel.org/r/20230406171806.948290-3-cristian.ciocaltea@collabora.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 36f098e1e4d1a372329c6244b220047a19e60dbd
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Apr 3 13:54:37 2023 +0200

    netfilter: br_netfilter: fix recent physdev match breakage
    
    [ Upstream commit 94623f579ce338b5fa61b5acaa5beb8aa657fb9e ]
    
    Recent attempt to ensure PREROUTING hook is executed again when a
    decrypted ipsec packet received on a bridge passes through the network
    stack a second time broke the physdev match in INPUT hook.
    
    We can't discard the nf_bridge info strct from sabotage_in hook, as
    this is needed by the physdev match.
    
    Keep the struct around and handle this with another conditional instead.
    
    Fixes: 2b272bb558f1 ("netfilter: br_netfilter: disable sabotage_in hook after first suppression")
    Reported-and-tested-by: Farid BENAMROUCHE <fariouche@yahoo.fr>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 375e445b1022e7385251179a42e3bbb1530ba71c
Author: Marc Gonzalez <mgonzalez@freebox.fr>
Date:   Mon Mar 27 14:09:30 2023 +0200

    arm64: dts: meson-g12-common: specify full DMC range
    
    [ Upstream commit aec4353114a408b3a831a22ba34942d05943e462 ]
    
    According to S905X2 Datasheet - Revision 07:
    DRAM Memory Controller (DMC) register area spans ff638000-ff63a000.
    
    According to DeviceTree Specification - Release v0.4-rc1:
    simple-bus nodes do not require reg property.
    
    Fixes: 1499218c80c99a ("arm64: dts: move common G12A & G12B modes to meson-g12-common.dtsi")
    Signed-off-by: Marc Gonzalez <mgonzalez@freebox.fr>
    Reviewed-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Link: https://lore.kernel.org/r/20230327120932.2158389-2-mgonzalez@freebox.fr
    Signed-off-by: Neil Armstrong <neil.armstrong@linaro.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit cb1f89fe934bc280103d9fa38a51b2af4c53724f
Author: Jianqun Xu <jay.xu@rock-chips.com>
Date:   Wed Feb 8 17:14:11 2023 +0800

    ARM: dts: rockchip: fix a typo error for rk3288 spdif node
    
    [ Upstream commit 02c84f91adb9a64b75ec97d772675c02a3e65ed7 ]
    
    Fix the address in the spdif node name.
    
    Fixes: 874e568e500a ("ARM: dts: rockchip: Add SPDIF transceiver for RK3288")
    Signed-off-by: Jianqun Xu <jay.xu@rock-chips.com>
    Reviewed-by: Sjoerd Simons <sjoerd@collabora.com>
    Link: https://lore.kernel.org/r/20230208091411.1603142-1-jay.xu@rock-chips.com
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
